---
interface Props {
  title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Daniel Frevel - Full-Stack Developer" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet" />
    <title>{title}</title>
    <script is:inline>
      const t = localStorage.getItem('theme') ??
        (matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
      document.documentElement.classList.toggle('dark', t === 'dark');
    </script>
  </head>
  <body class="bg-amber-50 dark:bg-slate-950 text-stone-800 dark:text-stone-100 font-mono antialiased transition-colors duration-700">
    <canvas id="weather" class="fixed inset-0 pointer-events-none z-0"></canvas>
    <div class="relative z-10">
      <slot />
    </div>
  </body>
</html>

<style is:global>
  html {
    scroll-behavior: smooth;
  }
</style>

<script>
const canvas = document.getElementById('weather') as HTMLCanvasElement;
const ctx = canvas.getContext('2d')!;
const reducedMotion = matchMedia('(prefers-reduced-motion:reduce)').matches;

let currentFrame: number | null = null;
let paused = false;

let currentMode: 'rain' | 'sun' = 'sun';
let transition = 0;
let transitionTarget: 'rain' | 'sun' | null = null;
const TRANSITION_SPEED = 0.02;

function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
resize();
addEventListener('resize', resize);

// Rain state
const CHARS = '||||||||/\\'.split('');
const SIZE = 14;
let drops: {x:number,y:number,c:string,s:number,a:number,o:number}[] = [];
const GRAVITY = 0.04;
const MAX_SPEED = 12;
let flash = 0;
let bolts: {points:{x:number,y:number}[],o:number}[] = [];
let impacts: {x:number,y:number,r:number,o:number,sparks:{x:number,y:number,vx:number,vy:number,o:number}[]}[] = [];

// Sun state
let sunTime = 0;
let motes: {x:number,y:number,s:number,o:number,dx:number,dy:number}[] = [];
const RAY_COUNT = 12;

function createBolt(startX: number): {points:{x:number,y:number}[], hitType:'none'|'ground'|'left'|'right'} {
  const points = [{x: startX, y: 0}];
  let x = startX, y = 0;
  const hitsEdge = Math.random() < 0.4;
  const endY = hitsEdge ? canvas.height : canvas.height * (0.4 + Math.random() * 0.4);
  let hitType: 'none'|'ground'|'left'|'right' = hitsEdge ? 'ground' : 'none';

  while (y < endY) {
    y += 20 + Math.random() * 40;
    x += (Math.random() - 0.5) * 100;
    if (y > endY) y = endY;

    if (x <= 0) {
      x = 0;
      hitType = 'left';
      points.push({x, y});
      break;
    }
    if (x >= canvas.width) {
      x = canvas.width;
      hitType = 'right';
      points.push({x, y});
      break;
    }

    points.push({x, y});
    if (Math.random() < 0.3 && points.length > 2) {
      const branch: {x:number,y:number}[] = [{x, y}];
      let bx = x, by = y;
      for (let i = 0; i < 3; i++) {
        by += 15 + Math.random() * 25;
        bx += (Math.random() - 0.5) * 60;
        branch.push({x: bx, y: by});
      }
      bolts.push({points: branch, o: 1});
    }
  }
  return {points, hitType};
}

function drawBolt(points: {x:number,y:number}[], opacity: number) {
  ctx.strokeStyle = `rgba(220,220,255,${opacity})`;
  ctx.lineWidth = 3;
  ctx.shadowColor = `rgba(200,200,255,${opacity * 0.8})`;
  ctx.shadowBlur = 30;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }
  ctx.stroke();
  ctx.shadowBlur = 0;
}

function updateRain(alpha: number) {
  if (alpha > 0.3 && Math.random() < 0.08 && drops.length < 150) {
    drops.push({
      x: Math.random() * canvas.width,
      y: -SIZE,
      c: CHARS[Math.floor(Math.random() * CHARS.length)],
      s: 0.5 + Math.random() * 1.5,
      a: GRAVITY * (0.8 + Math.random() * 0.4),
      o: 0.2 + Math.random() * 0.3
    });
  }

  if (alpha > 0.5 && bolts.length === 0 && Math.random() < 0.003) {
    const bolt = createBolt(Math.random() * canvas.width);
    bolts.push({points: bolt.points, o: 1});
    flash = bolt.hitType !== 'none' ? 0.35 : 0.25;

    if (bolt.hitType !== 'none') {
      const lastPoint = bolt.points[bolt.points.length - 1];
      const sparks = [];
      const sparkCount = 8;

      for (let i = 0; i < sparkCount; i++) {
        let angle: number;
        if (bolt.hitType === 'ground') {
          angle = -Math.PI * (0.2 + Math.random() * 0.6);
        } else if (bolt.hitType === 'left') {
          angle = -Math.PI * 0.25 + Math.random() * Math.PI * 0.5;
        } else {
          angle = Math.PI * 0.75 + Math.random() * Math.PI * 0.5;
        }
        const speed = 2 + Math.random() * 4;
        sparks.push({
          x: lastPoint.x, y: lastPoint.y,
          vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
          o: 0.8 + Math.random() * 0.2
        });
      }
      impacts.push({x: lastPoint.x, y: lastPoint.y, r: 5, o: 1, sparks});
    }
  }

  if (flash > 0) {
    ctx.fillStyle = `rgba(150,150,170,${flash * alpha})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    flash *= 0.85;
    if (flash < 0.005) flash = 0;
  }

  bolts = bolts.filter(b => {
    drawBolt(b.points, b.o * alpha);
    b.o *= 0.9;
    return b.o > 0.05;
  });

  impacts = impacts.filter(imp => {
    const grad = ctx.createRadialGradient(imp.x, imp.y, 0, imp.x, imp.y, imp.r);
    grad.addColorStop(0, `rgba(220,220,255,${imp.o * 0.6 * alpha})`);
    grad.addColorStop(0.5, `rgba(180,180,255,${imp.o * 0.3 * alpha})`);
    grad.addColorStop(1, `rgba(150,150,255,0)`);
    ctx.fillStyle = grad;
    ctx.fillRect(imp.x - imp.r, imp.y - imp.r, imp.r * 2, imp.r * 2);

    imp.sparks = imp.sparks.filter(s => {
      ctx.beginPath();
      ctx.arc(s.x, s.y, 2, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(220,220,255,${s.o * alpha})`;
      ctx.fill();
      s.x += s.vx;
      s.y += s.vy;
      s.vy += 0.15;
      s.o -= 0.03;
      return s.o > 0 && s.y < canvas.height + 10;
    });

    imp.r += 3;
    imp.o -= 0.04;
    return imp.o > 0 || imp.sparks.length > 0;
  });

  ctx.font = `${SIZE}px "JetBrains Mono",monospace`;
  drops = drops.filter(d => {
    ctx.fillStyle = `rgba(113,113,122,${d.o * alpha})`;
    ctx.fillText(d.c, d.x, d.y);
    d.y += d.s;
    d.s = Math.min(d.s + d.a, MAX_SPEED);
    return d.y < canvas.height + SIZE;
  });
}

function updateSun(alpha: number) {
  sunTime += 0.006;
  const sunX = canvas.width + 80;
  const sunY = -80;

  const glowGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 350);
  glowGrad.addColorStop(0, `rgba(251, 191, 36, ${0.25 * alpha})`);
  glowGrad.addColorStop(0.5, `rgba(251, 191, 36, ${0.08 * alpha})`);
  glowGrad.addColorStop(1, 'rgba(251, 191, 36, 0)');
  ctx.fillStyle = glowGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const baseOpacity = (0.18 + Math.sin(sunTime) * 0.04) * alpha;
  for (let i = 0; i < RAY_COUNT; i++) {
    const angle = (Math.PI * 0.4) + (Math.PI * 0.9) * (i / (RAY_COUNT - 1));
    const length = 500 + Math.sin(sunTime * 0.8 + i * 0.5) * 80;
    const xPulse = Math.sin(sunTime * 0.8 + i * 0.5) * 60;

    const endX = sunX + Math.cos(angle) * length - xPulse;
    const endY = sunY + Math.sin(angle) * length;

    const grad = ctx.createLinearGradient(sunX, sunY, endX, endY);
    grad.addColorStop(0, `rgba(251, 191, 36, ${baseOpacity})`);
    grad.addColorStop(0.7, `rgba(251, 191, 36, ${baseOpacity * 0.3})`);
    grad.addColorStop(1, 'rgba(251, 191, 36, 0)');

    ctx.beginPath();
    ctx.moveTo(sunX, sunY);
    const spread = 0.06 + Math.sin(sunTime + i) * 0.02;
    ctx.lineTo(
      sunX + Math.cos(angle - spread) * length - xPulse,
      sunY + Math.sin(angle - spread) * length
    );
    ctx.lineTo(
      sunX + Math.cos(angle + spread) * length - xPulse,
      sunY + Math.sin(angle + spread) * length
    );
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();
  }

  if (alpha > 0.3 && Math.random() < 0.07 && motes.length < 50) {
    motes.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      s: 1.5 + Math.random() * 2.5,
      o: 0.25 + Math.random() * 0.25,
      dx: (Math.random() - 0.5) * 0.25,
      dy: -0.1 - Math.random() * 0.15
    });
  }

  motes = motes.filter(m => {
    const twinkle = 0.75 + Math.sin(sunTime * 2 + m.x * 0.01) * 0.25;
    ctx.beginPath();
    ctx.arc(m.x, m.y, m.s, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(251, 191, 36, ${m.o * twinkle * alpha})`;
    ctx.fill();
    m.x += m.dx;
    m.y += m.dy;
    m.o -= 0.001;
    return m.o > 0 && m.y > -10 && m.x > -10 && m.x < canvas.width + 10;
  });
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (transitionTarget) {
    transition += TRANSITION_SPEED;
    if (transition >= 1) {
      transition = 0;
      currentMode = transitionTarget;
      transitionTarget = null;
    }
  }

  let rainAlpha = 0, sunAlpha = 0;

  if (transitionTarget) {
    if (transitionTarget === 'rain') {
      sunAlpha = 1 - transition;
      rainAlpha = transition;
    } else {
      rainAlpha = 1 - transition;
      sunAlpha = transition;
    }
  } else {
    rainAlpha = currentMode === 'rain' ? 1 : 0;
    sunAlpha = currentMode === 'sun' ? 1 : 0;
  }

  if (sunAlpha > 0) updateSun(sunAlpha);
  if (rainAlpha > 0) updateRain(rainAlpha);

  if (!paused) currentFrame = requestAnimationFrame(render);
}

function startEffect(theme: string) {
  const target = theme === 'dark' ? 'rain' : 'sun';
  if (target === currentMode && !transitionTarget) return;
  transitionTarget = target;
  transition = 0;
}

function initEffect(theme: string) {
  currentMode = theme === 'dark' ? 'rain' : 'sun';
  if (reducedMotion) return;
  render();
}

function togglePause(): boolean {
  paused = !paused;
  if (!paused && !reducedMotion) render();
  return paused;
}

const isDark = document.documentElement.classList.contains('dark');
initEffect(isDark ? 'dark' : 'light');

(window as any).startWeatherEffect = startEffect;
(window as any).toggleWeatherPause = togglePause;
</script>
