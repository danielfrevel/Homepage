---
interface Props {
  title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Daniel Frevel - Full-Stack Developer" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet" />
    <title>{title}</title>
    <script is:inline>
      const t = localStorage.getItem('theme') ??
        (matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
      document.documentElement.classList.toggle('dark', t === 'dark');
    </script>
  </head>
  <body class="bg-zinc-100 dark:bg-zinc-950 text-zinc-900 dark:text-zinc-100 font-mono antialiased">
    <canvas id="weather" class="fixed inset-0 pointer-events-none z-0"></canvas>
    <div class="relative z-10">
      <slot />
    </div>
  </body>
</html>

<style is:global>
  html {
    scroll-behavior: smooth;
  }
</style>

<script>
const canvas = document.getElementById('weather') as HTMLCanvasElement;
const ctx = canvas.getContext('2d')!;
const reducedMotion = matchMedia('(prefers-reduced-motion:reduce)').matches;

let currentFrame: number | null = null;
let paused = false;

function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
resize();
addEventListener('resize', resize);

// Rain effect
const CHARS = '||||||||/\\'.split('');
const SIZE = 14;
let drops: {x:number,y:number,c:string,s:number,o:number}[] = [];
let flash = 0;
let bolts: {points:{x:number,y:number}[],o:number}[] = [];

function createBolt(startX: number) {
  const points = [{x: startX, y: 0}];
  let x = startX, y = 0;
  const endY = canvas.height * (0.4 + Math.random() * 0.5);
  while (y < endY) {
    y += 20 + Math.random() * 40;
    x += (Math.random() - 0.5) * 100;
    points.push({x, y});
    if (Math.random() < 0.3 && points.length > 2) {
      const branch: {x:number,y:number}[] = [{x, y}];
      let bx = x, by = y;
      for (let i = 0; i < 3; i++) {
        by += 15 + Math.random() * 25;
        bx += (Math.random() - 0.5) * 60;
        branch.push({x: bx, y: by});
      }
      bolts.push({points: branch, o: 1});
    }
  }
  return points;
}

function drawBolt(points: {x:number,y:number}[], opacity: number) {
  ctx.strokeStyle = `rgba(220,220,255,${opacity})`;
  ctx.lineWidth = 3;
  ctx.shadowColor = `rgba(200,200,255,${opacity * 0.8})`;
  ctx.shadowBlur = 30;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }
  ctx.stroke();
  ctx.shadowBlur = 0;
}

function runRain() {
  if (Math.random() < 0.05 && drops.length < 120) {
    drops.push({
      x: Math.random() * canvas.width,
      y: -SIZE,
      c: CHARS[Math.floor(Math.random() * CHARS.length)],
      s: 0.3 + Math.random() * 0.8,
      o: 0.25 + Math.random() * 0.25
    });
  }

  if (bolts.length === 0 && Math.random() < 0.0075) {
    bolts.push({points: createBolt(Math.random() * canvas.width), o: 1});
    flash = 0.25;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (flash > 0) {
    ctx.fillStyle = `rgba(150,150,170,${flash})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    flash *= 0.85;
    if (flash < 0.005) flash = 0;
  }

  bolts = bolts.filter(b => {
    drawBolt(b.points, b.o);
    b.o *= 0.9;
    return b.o > 0.05;
  });

  ctx.font = `${SIZE}px "JetBrains Mono",monospace`;
  drops = drops.filter(d => {
    ctx.fillStyle = `rgba(113,113,122,${d.o})`;
    ctx.fillText(d.c, d.x, d.y);
    d.y += d.s;
    return d.y < canvas.height + SIZE;
  });

  if (!paused) currentFrame = requestAnimationFrame(runRain);
}

// Sun effect
let sunTime = 0;
let motes: {x:number,y:number,s:number,o:number,dx:number,dy:number}[] = [];
const RAY_COUNT = 12;

function runSun() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  sunTime += 0.016;

  const sunX = canvas.width + 80;
  const sunY = -80;

  // Sun glow
  const glowGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 350);
  glowGrad.addColorStop(0, 'rgba(251, 191, 36, 0.25)');
  glowGrad.addColorStop(0.5, 'rgba(251, 191, 36, 0.08)');
  glowGrad.addColorStop(1, 'rgba(251, 191, 36, 0)');
  ctx.fillStyle = glowGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Rays
  const baseOpacity = 0.18 + Math.sin(sunTime) * 0.04;
  for (let i = 0; i < RAY_COUNT; i++) {
    const angle = (Math.PI * 0.4) + (Math.PI * 0.9) * (i / (RAY_COUNT - 1));
    const length = 500 + Math.sin(sunTime * 0.8 + i * 0.5) * 80;
    const xPulse = Math.sin(sunTime * 0.8 + i * 0.5) * 60;

    const endX = sunX + Math.cos(angle) * length - xPulse;
    const endY = sunY + Math.sin(angle) * length;

    const grad = ctx.createLinearGradient(sunX, sunY, endX, endY);
    grad.addColorStop(0, `rgba(251, 191, 36, ${baseOpacity})`);
    grad.addColorStop(0.7, `rgba(251, 191, 36, ${baseOpacity * 0.3})`);
    grad.addColorStop(1, 'rgba(251, 191, 36, 0)');

    ctx.beginPath();
    ctx.moveTo(sunX, sunY);
    const spread = 0.06 + Math.sin(sunTime + i) * 0.02;
    ctx.lineTo(
      sunX + Math.cos(angle - spread) * length - xPulse,
      sunY + Math.sin(angle - spread) * length
    );
    ctx.lineTo(
      sunX + Math.cos(angle + spread) * length - xPulse,
      sunY + Math.sin(angle + spread) * length
    );
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();
  }

  // Dust motes / sparkles
  if (Math.random() < 0.07 && motes.length < 50) {
    motes.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      s: 1.5 + Math.random() * 2.5,
      o: 0.25 + Math.random() * 0.25,
      dx: (Math.random() - 0.5) * 0.25,
      dy: -0.1 - Math.random() * 0.15
    });
  }

  motes = motes.filter(m => {
    const twinkle = 0.75 + Math.sin(sunTime * 2 + m.x * 0.01) * 0.25;
    ctx.beginPath();
    ctx.arc(m.x, m.y, m.s, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(251, 191, 36, ${m.o * twinkle})`;
    ctx.fill();
    m.x += m.dx;
    m.y += m.dy;
    m.o -= 0.001;
    return m.o > 0 && m.y > -10 && m.x > -10 && m.x < canvas.width + 10;
  });

  if (!paused) currentFrame = requestAnimationFrame(runSun);
}

function startEffect(theme: string) {
  if (currentFrame) cancelAnimationFrame(currentFrame);
  drops = [];
  bolts = [];
  flash = 0;
  motes = [];
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (reducedMotion) return;
  theme === 'dark' ? runRain() : runSun();
}

function togglePause(): boolean {
  paused = !paused;
  if (!paused && !reducedMotion) {
    const isDark = document.documentElement.classList.contains('dark');
    isDark ? runRain() : runSun();
  }
  return paused;
}

// Init and expose for toggle
const isDark = document.documentElement.classList.contains('dark');
startEffect(isDark ? 'dark' : 'light');

(window as any).startWeatherEffect = startEffect;
(window as any).toggleWeatherPause = togglePause;
</script>
